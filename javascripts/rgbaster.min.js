;(function(window, undefined){

    "use strict";

    // Helper functions.
    var getContext = function(){
        return document.createElement("canvas").getContext('2d');
    };

    var getImageData = function(img, loaded){

        var imgObj = new Image();

        // Can't set cross origin to be anonymous for data url's
        // https://github.com/mrdoob/three.js/issues/1305
        if ( img.src.substring(0,5) !== 'data:' )
            imgObj.crossOrigin = "Anonymous";

        imgObj.src = img.src;

        imgObj.onload = function(){
            var context = getContext();
            context.drawImage(imgObj, 0, 0);

            var imageData = context.getImageData(0, 0, img.width, img.height);
            loaded && loaded(imageData.data);
        };

    };

    var makeRGB = function(name){
        return [name].join('');
    };

    var mapPalette = function(palette){
        return palette.map(function(c){ return makeRGB(c.name) })
    }

    /**
     *     RGBaster Object
     *
     *     @method colors
     *
     */
    var BLOCKSIZE = 1;
    var PALETTESIZE = 10;

    var RGBaster = {};

    RGBaster.colors = function(img, success, paletteSize){
        getImageData(img, function(data){

            var length        = data.length,
                colorCounts   = {},
                rgbString     = '',
                rgb           = [],
                colors        = {
                    dominant: { name: '', count: 0 },
                    palette:  Array.apply(null, Array(paletteSize || PALETTESIZE)).map(Boolean).map(function(a){ return { name: '0,0,0', count: 0 } })
                };

            // Loop over all pixels, in BLOCKSIZE iterations.
            var i = 0;
            while ( i < length ) {
                rgb[0] = data[i];
                rgb[1] = data[i+1];
                rgb[2] = data[i+2];
                rgbString = rgb.join(",");

                // Keep track of counts.
                if ( rgbString in colorCounts ) {
                    colorCounts[rgbString] = colorCounts[rgbString] + 1;
                }
                else{
                    colorCounts[rgbString] = 1;
                }

                // Find dominant and palette, ignoring black/white pixels.
                if ( rgbString !== "0,0,0" && rgbString !== "255,255,255" ) {
                    var colorCount = colorCounts[rgbString]
                    if ( colorCount > colors.dominant.count ){
                        colors.dominant.rgb = rgb.slice();
                        colors.dominant.name = rgbString;
                        colors.dominant.count = colorCount;
                    } else {
                        colors.palette.some(function(c){
                            if ( colorCount > c.count ) {
                                c.rgb = rgb.slice();
                                c.name = rgbString;
                                c.count = colorCount;
                                return true;
                            }
                        });
                    }
                }

                // Increment!
                i += BLOCKSIZE * 4;
            }
            success && success({
                dominantUnwrapped: colors.dominant.rgb,
                dominant: makeRGB(colors.dominant.name),
                palette:  mapPalette(colors.palette)
            });
        });
    }

    window.RGBaster = window.RGBaster || RGBaster;

})(window);